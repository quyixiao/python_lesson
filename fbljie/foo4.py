# 但是，如果构成了循环的递归调用是非常的危险的，但是往往这种情况下代码的复杂情况下，还是可能发生这种调用的，要用代码的规范来避免这种问题
# 这种递归调用发生了
# 递归是一种很自然的
# 即使递归代码是非常的简单的，但是能不用的情况下，最好是不要使用
# 绝大的多数的递归，都可以使用循环来实现
# 如果是限制次数的递归，可以使用递归调用，或者使用循环代替，循环代码稍微的复杂一些，但是只要不是死循环，可以多次迭代的使用递归
# 求n 阶乘
# 将一个放入到列表中，1234 [4,3,2,1]
#

def njiecheng(n):
    if n < 2:
        return 1
    return n * njiecheng(n - 1)


print(njiecheng(5))


def factorial(n, mul=1):
    mul *= n
    if n == 1:
        return mul
    return factorial(n - 1, mul)


print(factorial(5))


def nreversed(a, n):
    if a is None:
        a = []
    if n < 10:
        a.append(n)
    else:
        b = n % 10
        a.append(b)
        n = n // 10
        a = nreversed(a, n)
    return a


a = nreversed([], 123456789)
print(a)

data = str(1234)


# 函数定义成一个，

def reversal(x):
    if x == -1:
        return ''
    else:
        return data[x] + reversal(x - 1)


print(reversal(len(data) - 1))

num = 1234

print('----------------------------')


# 如果是关键字参数，确实不是关键字参数，怎样才能出现关键字参数，如果这个关键字参数是这样的，强制的关键字参数
#
# 通过这种方式，就拿到了最后的4 - 3 - 2 - 1 ,可变的不需要写缺省的值，要么是位置参数加缺省的值，要么是，kwd
# 普通的位置参数的缺省值是，前后各有两个参数，当你对这个值有了深入的理解以后，对每一次return 之后，最后的return ,什么时候需要
# 缺省的值是，所以到了函数的这一块，函数的写法有千变万化了，但是别人用了很多的python的特点，我用了N次reverted ,同一个函数的对象
# 同一个函数的对象，default 也是一个，但是default 的本身也是发生了变化，所以每次在利用值的时候，一定要清楚在内存中是怎样玩的，
# 弄不清楚内存，则不会编程，栈是函数一个个的压上去，栈底到栈顶，还是函数的参数是压的是自己的东西，还是其他的东西，还是自己的东西，猴子吃桃的问题
#
def revert(num, target=[]):
    if num:
        print('+++++++++', num)
        target.append(num[len(num) - 1])
        b = num[:len(num) - 1]
        print('=========', b)
        revert(b)
    return target


print(revert(str(num)))


# 计算机的资源是有限的，所以这是我们实现递归的问题，发现效率有问题，但是对于有些函数的表达 ，函数写是是基本上是一样的，计算机的使用条件是
# 通出的条件，就是在使用的过程中，计算机的实现的过程中，必须要加一个边界，当i = 4 的时候，i = 3 ,= 2 = 1 ,是怎样的一个情况，递归是无限
# 调用，层次是不应该过深的，限制是怎样来的呢? 对比了了这些，递归是有不同的写法，递归的效率，有层次的限制，请你能够使用，代码提交的情况
# 通过另一个的情况，在另一个的情况中，间接的调用，能不能递归调用，能不用，则不用，递归调用，在生产环境中，能不能就不用，如果好的实现算法，
# 账号，我也是改了一点的，不同的实现方式将是不一样的，这种实现的方式是，不同的实现方式是不一样的，不一样的，东西，如果多传递了一个参数
# 看上去是一样的，同一个东西，同一个地址，拿来是不一样的，我只是告诉你，这个东西是可以用的，这几种实现方式在心里完成，猴子吃桃的问题
#


def monkey(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return 2 * monkey(n - 1) + 2


print(monkey(10))

print('-----------------------------')


# 如果用户对用户的行为进行判断，.1 可以转换成0.1 的，这容错的情况，友好性，用户可以写成0.1a ,将用户的参数进行判断的，等于1的
# 是不是拿到上一次的值，每次进行判断，这是一种实现方式，两个情况都有，每次都进行减一，
# 有没有从小数向上加的，另一个方向的思维，这些题都完成的都不错，还有一种，两种都一样，第一个题都实现的都不一样，换一种思路也是可以的
# 都是在记次，
def peach(day=9, sum=1):
    sum = 2 * (sum + 1)
    day -= 1
    if day == 0:
        return sum
    return peach(day, sum)


print(peach())
