# 在一个函数中定义了另一个函数
# 全局使用域
# 在函数的，类等内部可见
# 局部的变量的使用范围不能超过其所在的局部使用域中
# 内层函数用到了外层函数的全局变量，外层函数的全局变量，自由变量是什么，内层函数使用到了外层的自由变量
# 如果要对普通变量的闭包，Python3 中可以使用nonlocal
# 外层，

# 使用了nonlocal 关键字，将变量标记为在上级的局部变量中定义，但是不能是全局使用域中的定义
# count 在外层函数的局部变量，将被内部函数引用
#
def counter():
    count = 0
    # count 外层函数的局部变量，被内部函数引用
    # 内部函数使用nonlocal关键字声明count变量在上一级的使用的局部使用域
    # 左边的代码可以正常的使用，且形成闭包
    #
    def inc():
        nonlocal count  # 是上一级的非全局使用域的局部使用域，在外部定义过了，到上一级去找，
        count += 1
        return count

    return inc

# 通过nonlocal 来实现这一点的，直接打印这个是没有问题，引用之前，这个本地变量是要赋值的，nonlocal
foo = counter()
print(foo())
print(foo())
