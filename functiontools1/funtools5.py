import functools

#
@functools.lru_cache(maxsize=200)
def fib(n):
    if n < 3:
        return 1
    return fib(n - 1) + fib(n - 2)


for i in range(1, 35):
    print(fib(i))


# 在使用相同函数的时候，这些，如果是公共的，如果用递归的方式，来实现他的实现方式
# 递归重复的计算方式，计算的方式，大大减少了，同样的函数，肯定得到同样的结果
# 传入的参数一样，得到的结果一定一样，
#  如果函数执行的时候特别的长，本质是，由函数调用的参数，字典的查询，效率极高，
# 装饰器的，但是没有过期时间，无法失效，不支持分布式，
# 单机，需要空间换时间，用缓存来计算，来加快速度，
#  如果缓存，失效，要求这个结果
