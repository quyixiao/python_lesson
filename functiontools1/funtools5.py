import functools


#
@functools.lru_cache(maxsize=200)
def fib(n):
    if n < 3:
        return 1
    return fib(n - 1) + fib(n - 2)


for i in range(1, 35):
    print(fib(i))

# 在使用相同函数的时候，这些，如果是公共的，如果用递归的方式，来实现他的实现方式
# 递归重复的计算方式，计算的方式，大大减少了，同样的函数，肯定得到同样的结果
# 传入的参数一样，得到的结果一定一样，
#  如果函数执行的时候特别的长，本质是，由函数调用的参数，字典的查询，效率极高，
# 装饰器的，但是没有过期时间，无法失效，不支持分布式，
# 单机，需要空间换时间，用缓存来计算，来加快速度，
#  如果缓存，失效，要求这个结果
#
# 实现一个 cache 装饰器，实现过期被清除的功能
# 简化设计，函数的形参定义不包含可变的位置参数，可变关键词参数的 keyword-only 参数
# 可以不考虑缓存 之后的换出问题
# 写一个命令分发器
# 程序员可以方便注册函数到某一个命令，用户输入命令时，路由注册的函数
#  如果此命令没有对应的注册函数，执行默认的函数
#  用户输入用 input(">>")