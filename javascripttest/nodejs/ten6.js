function show(i,args) { 
    console.log(i,args);
 }
 //作用域
var x = 500;
 function fn(){
     let z = 400;
    {
        var o = 100;// var 作用域当前上下文
        show(1,x);
        t = 'free';//此语句执行后，t的t作用域是全局的，不推荐
        let p = 200;
    }
    var y = 300;
    show(2,z);
    show(3,t);
    show(4,o);
    show(5,t);
    //show(6 ,p);//异常，let 出不来上一个语句块
    {
        show(7,y);
        show(8,o);
        show(9,t);
        {
            show(10,o);
            show(11,t);
            show(12,z);
        }
    }
 }
 // 先执行函数
fn();
show(13,y);//异常，y只能存在于定义的上下文中，出来了函数
show(14,t);     //全局，但是严格意义上是会有问题的
//show(15,o);
show(16,z);
var z = 10;
const m = 1;
// 函数的参数
 //  普通参数
 var y 
 // 一个参数占用一个位置，支持默认参数

 const add = (x,y)=>x+y;
 console.log(add(4,5));
 // 参数解析，比python 更加的强大
 // 参数解析，可以将一个数组解构，参数解构，返回值是多值的
 // 类语言 函数的定义形参定义，作用域，无非，like,const , 隐式的定义，在严格的意义上是不允许的
 // x = 5 ,前面，变量的赋值，连定义带赋值，全局变量会带来问题，所以尽量不要使用全局变量，在函数中多使用var ,let 
 // 在函数中，都使用let 
 //  严格的模式下的定义，这个应该是这样的
 // 严格模式来定义的
 // JS 的对象模型
 // JavaScript 是一种基于原型的面向对象语言，而不是基于类的面向对象语言
 // C++ ，Java 有类Class实例Instance的概念，类是一类事物的抽象，而实例是类的实体
 // JS 是基于原型的语言，它只有原型的对象的概念，原型就是一个模版，就是对象从这个模板建从而获取最初的属性，任何对在运行时可以动态的增加属性，而且，任何一个对象都可以
 // 作为另一个对象的原型，这样的后者都可以以共享前者的属性。
 // 
