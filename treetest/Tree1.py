# 非线性结构，每个元素可以有多个前驱和后继
# 树是n(n>=0 ) 个元素集合。
#   n = 0 ，称为空树
#   树只有一个特殊的没有前驱的元素，称为树的根的root
#   树中除了根结点外，其余元素只能有一个前驱，可以有零个或多个后继
#   递归定义
#   树T 是n(n>= 0 ) 个元素的集合，n = 0 时，称为空树
#   有且只有一个特殊元素，剩余的元素都可以被划分m个互不相交的集合，t1,t2,t3,...tm，而每个集合都是树
#   称为集合是都是树，称为T是取取经，subtree
#   子树也是处自己的根
#   树的概念
#   结点，树中的数据元素。
#   结点的度degree,结点拥有的子树数目为度，记作 d(v)
#   叶子结点，结点的度为0，称为叶子结点的leaf ,终端的结点，未端结点
#   分支结点，结点的度不为0，称为非终端结点，或分支结点
#   分支，结点之间的关系。
#   内部结点，除根结点之间的关系，
#   内部结点，除了根结点之外的分支结点，当然也不包括叶子结点。
#   树的度是树内结点的度的最大值，D 结点的度的最大值是3，树的度就是3
#   树的概念：
#   孩子结点： 结点的子树的根结点成为孩子的结点的孩子
#   双亲结点：一个结点是它的各子结点的双亲
#   兄弟结点，具有相同的双亲结点
#   祖先结点： 从根结点到该结点经过的分支上的所有的结点,A,B,D都是G祖先结点
#   子孙结点：结点的所有的子树上的所有的结点都称为该结点的子孙，B 的子孙 是D,G,H,I
#   结点的层次（Level） :根结点为第一层，根的孩子是第二层，以此类推，记作L（v）
#   树的深度（高度Depth）:树的层次是最大值，上图的树的深度为4
#   堂兄弟：双亲在同一层的结点
#   有序树：结点的子树是有顺序的，（兄弟有大小，有先后次序），不能交换
#   无序树，结点的子树是有无序的，可以交换
#   路径，树中的k个结点n1,n2,...nk,满足ni是n(i+1)的双亲，成为一个n1 到nk的一个路径，就是一条线串下来的
#   前一个是后一个的父亲前驱结点
#   路径的长度= 路径上的结点的数-1 ，也是分支数
#   森林： m(m >= 0 )树不相交，的树的集合
#   对于结点而言，其子树的集合就是森林，A 结点的2棵子树的集合就是森林
#
#  树的特点
#   唯一的根
#   子树不相交
#   除了根以外，每个元素都只能有一个前驱，可以有零个或者多个后继
#   根结点没有双亲结点（前驱），叶子结点没有孩子结点（后继 ）
#   路径
#   二叉树
#   每个结点最多2棵子树
#   二叉树不存在度数大于2的结点
#   它是有序树，左子树，右子树是顺序的，不能交换次序
#   即使某个结点只有一棵子树，也要确定它是左子树，还是右子树
#   二叉树的五种基本形态
#   斜对
#   左子树：
#   对任何一棵二叉树T,如果其终端节点数为n0,度数为2 的结点为n2 ,则有n0 = n2 + 1
#   换句话说，就是叶子结点数 = 度为为2 的结点数
#   含有n个结点的二叉树最多
#   具有n个结点的完全二叉树的深度为int(log2 n) + 1 或者math.ceil(log2(n + 1 ))
#   如果2i+1 > n ，则结点i无右孩子，如果2i + n 没有孩子，大于n的情况下，是，这就是
#   变量名解析原则legb
#   local,本地作用域，局部作用域的local命名空间，函数调用的时候创建，调用结束消亡
#   enlosing,Python2.2时引入了嵌套的函数，实现了闭包，这是嵌套的函数的外部函数的命名空间
#   Glocal，全局的作用域，即一个模块的命名空间，模块被inport 的时候创建，在退出的时候消亡
#   Build-in ，内置的模块的命名空间，生命周期从python解释器启动时创建到解释器退出时消亡，
#   例如，print(open),print(),open()都是内置变量。
#   所以一个名字的查找顺序就是LEGB
#   由内向外找，Global 嵌套函数中的内层函数中使用,嵌套函数中，向上面问，如果还是一个函数的情况
#   最里面的情况，变量，向外层的使用，嵌套函数中可能有闭包，
#

# 全局帧生成的foo1 ,foo2,foo3 ,main 函数对象
# main 函数的调用
# main 查找内建函数print 压栈，将常量的字符串压栈，调用函数，弹出栈顶
# main 中的全局查找函数foo1压栈，将常量100，101压栈，调用函数foo1,创建栈帧，将字符串和变量b,b1 压栈，调用函数，弹出栈顶，返回值
# main中的全局查找foo2 函数压栈，变量c引用压栈，调用foo3 ，创建栈，返回值，main 中的foo2 调用结束弹出栈顶，将继续执行print函数调用
# 弹出栈顶，main()函数的返回,但是这个是源码。
#  如果函数出栈，函数的执行流程是非常的重要，都需要一个保护现场，如果出栈，
# 递归recursion
# 函数直接或者间接调用自身就是递归
# 递归需要有边界条件，递归前进段，递归的返回段
# 递归直接的调用自己，间接调用，
# 当边界条件不满足的时候，递归的前进
# 当边界条件满足的时候，递归返回
# LOAD_GLBAL    函数高朋和，调用守成后，弹出所有的函数码数，函数本身，python 一定有一个返回值，函数怎样玩的，就是怎样的
# 如何准备的，弹出去怎样
# 函数执行是在消耗栈，栈是有大小在的，栈是在线程和进程之间，扩展的一点是为了，结合起来去理解
# 递归 ， 可以无限的去查看，对于计算机来说，我们问题一定是一个边界条件
def foo1(b, b1=3):
    print('foo1 called ', b, b1)


def foo2(c):
    foo3(c)
    print('foo2 called ', c)


def foo3(d):
    print('foo3 called ', d)


def main():
    print('main called')
    foo1(100, 101)
    foo2(200)
    print('main ending')


main()
